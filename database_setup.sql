-- Database Setup for Attendance Monitoring System
-- For a fresh Supabase project

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Drop existing policies if they exist
DO $$
BEGIN
    -- List all policies to drop
    PERFORM (
        SELECT format('DROP POLICY IF EXISTS %I ON storage.objects', polname)
        FROM pg_policy
        JOIN pg_class ON polrelid = pg_class.oid
        JOIN pg_namespace ON pg_class.relnamespace = pg_namespace.oid
        WHERE nspname = 'storage' AND relname = 'objects'
    );
END $$;

-- Create storage bucket for signatures
INSERT INTO storage.buckets (id, name, public)
VALUES ('signatures', 'signatures', true)
ON CONFLICT (name) DO NOTHING;

-- Create tables
CREATE TABLE IF NOT EXISTS public.profiles (
    id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    email TEXT UNIQUE NOT NULL,
    first_name TEXT,
    last_name TEXT,
    role TEXT NOT NULL DEFAULT 'user' CHECK (role IN ('admin', 'instructor', 'user')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.students (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id TEXT NOT NULL UNIQUE,
    firstname TEXT NOT NULL,
    middlename TEXT,
    surname TEXT NOT NULL,
    middle_initial TEXT,
    program TEXT NOT NULL,
    year TEXT NOT NULL,
    section TEXT NOT NULL,
    sex TEXT,
    address TEXT,
    birthday DATE,
    contact_no TEXT CHECK (contact_no ~ '^[0-9\-\+\(\)\s]+$'),
    email TEXT CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
    signature_urls TEXT[], -- Array to store multiple signature URLs
    signature_url TEXT,    -- Kept for backward compatibility
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.sessions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    program TEXT NOT NULL,
    year TEXT NOT NULL,
    section TEXT NOT NULL,
    date DATE NOT NULL,
    time_in TEXT,
    time_out TEXT,
    location TEXT,
    instructor TEXT NOT NULL,
    capacity TEXT,
    type TEXT NOT NULL DEFAULT 'class' CHECK (type IN ('class', 'event', 'other')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.attendance (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    session_id BIGINT NOT NULL REFERENCES public.sessions(id) ON DELETE CASCADE,
    student_id BIGINT NOT NULL REFERENCES public.students(id) ON DELETE CASCADE,
    status TEXT NOT NULL CHECK (status IN ('present', 'absent', 'late', 'excused')),
    time_in TIMESTAMP WITH TIME ZONE,
    time_out TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
    UNIQUE(session_id, student_id)
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_attendance_session_id ON public.attendance(session_id);
CREATE INDEX IF NOT EXISTS idx_attendance_student_id ON public.attendance(student_id);
CREATE INDEX IF NOT EXISTS idx_students_program_year_section ON public.students(program, year, section);
CREATE INDEX IF NOT EXISTS idx_sessions_program_year_section ON public.sessions(program, year, section);

-- Create trigger function for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW; 
END;
$$ language 'plpgsql';

-- Create triggers for updated_at
CREATE OR REPLACE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE TRIGGER update_students_updated_at
BEFORE UPDATE ON public.students
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE TRIGGER update_sessions_updated_at
BEFORE UPDATE ON public.sessions
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE TRIGGER update_attendance_updated_at
BEFORE UPDATE ON public.attendance
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Insert sample data (optional)
-- INSERT INTO public.programs (name, description) VALUES 
-- ('Computer Science', 'Bachelor of Science in Computer Science'),
-- ('Information Technology', 'Bachelor of Science in Information Technology');

-- Enable Row Level Security on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.students ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.attendance ENABLE ROW LEVEL SECURITY;

-- Create a function to check if current user is an admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = auth.uid() AND role = 'admin'
  );
$$ LANGUAGE sql SECURITY DEFINER;

-- Create a function to check if current user is an instructor
CREATE OR REPLACE FUNCTION is_instructor()
RETURNS BOOLEAN AS $$
  SELECT EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = auth.uid() AND role IN ('admin', 'instructor')
  );
$$ LANGUAGE sql SECURITY DEFINER;

-- Set up storage policies for signatures
CREATE POLICY "Allow public read access to signatures"
  ON storage.objects FOR SELECT
  USING (bucket_id = 'signatures');

CREATE POLICY "Allow authenticated uploads to signatures"
  ON storage.objects FOR INSERT
  WITH CHECK (
    bucket_id = 'signatures' AND
    auth.role() = 'authenticated'
  );

CREATE POLICY "Allow update/delete of own signatures"
  ON storage.objects FOR ALL
  USING (
    bucket_id = 'signatures' AND
    auth.role() = 'authenticated' AND
    (storage.filename(name) = auth.uid()::text || '%' OR is_admin())
  )
  WITH CHECK (
    bucket_id = 'signatures' AND
    auth.role() = 'authenticated' AND
    (storage.filename(name) = auth.uid()::text || '%' OR is_admin())
  );

-- Profiles policies
CREATE POLICY "Allow all for authenticated users"
  ON profiles FOR ALL
  USING (auth.role() = 'authenticated');

-- Students policies
CREATE POLICY "Allow all for authenticated users"
  ON students FOR ALL
  USING (auth.role() = 'authenticated');

-- Sessions policies
CREATE POLICY "Allow all for authenticated users"
  ON sessions FOR ALL
  USING (auth.role() = 'authenticated');

-- Attendance policies
CREATE POLICY "Allow all for authenticated users"
  ON attendance FOR ALL
  USING (auth.role() = 'authenticated');

-- Storage policies for public bucket (signatures)
CREATE POLICY "Public Access"
  ON storage.objects FOR SELECT
  USING (bucket_id = 'signatures');

CREATE POLICY "Enable insert for authenticated users only"
  ON storage.objects FOR INSERT
  WITH CHECK (
    bucket_id = 'signatures' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "Enable update for authenticated users only"
  ON storage.objects FOR UPDATE
  USING (
    bucket_id = 'signatures' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

CREATE POLICY "Enable delete for authenticated users only"
  ON storage.objects FOR DELETE
  USING (
    bucket_id = 'signatures' AND
    auth.role() = 'authenticated' AND
    (storage.foldername(name))[1] = auth.uid()::text
  );

-- Create storage bucket for signatures if it doesn't exist
INSERT INTO storage.buckets (id, name, public)
VALUES ('signatures', 'signatures', false)
ON CONFLICT (id) DO NOTHING;

-- Create a function to safely update student signatures
CREATE OR REPLACE FUNCTION public.update_student_signatures(
  p_student_id bigint,
  p_new_signature_url text
) RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
  v_current_urls text[];
  v_updated_urls text[];
  v_result jsonb;
  v_signature_count integer;
BEGIN
  -- Get current signature_urls in a thread-safe way
  SELECT COALESCE(signature_urls, ARRAY[]::text[]) 
  INTO v_current_urls 
  FROM students 
  WHERE id = p_student_id
  FOR UPDATE; -- This locks the row for the duration of the transaction

  -- Initialize as empty array if null
  IF v_current_urls IS NULL THEN
    v_current_urls := '{}';
  END IF;

  -- Add new URL to the beginning of the array if it's not already there
  IF NOT p_new_signature_url = ANY(v_current_urls) THEN
    v_updated_urls := array_prepend(p_new_signature_url, v_current_urls);
  ELSE
    v_updated_urls := v_current_urls;
  END IF;
  
  -- Calculate the signature count
  v_signature_count := array_length(v_updated_urls, 1);
  IF v_signature_count IS NULL THEN
    v_signature_count := 0;
  END IF;
  
  -- Update both the single URL and the array
  UPDATE students
  SET 
    signature_url = p_new_signature_url,
    signature_urls = v_updated_urls,
    signature_count = v_signature_count,
    updated_at = now()
  WHERE id = p_student_id
  RETURNING jsonb_build_object(
    'id', id,
    'signature_url', signature_url,
    'signature_urls', signature_urls,
    'signature_count', v_signature_count
  ) INTO v_result;
  
  RETURN v_result;
EXCEPTION WHEN OTHERS THEN
  RAISE EXCEPTION 'Error updating signatures: %', SQLERRM;
END;
$$;
